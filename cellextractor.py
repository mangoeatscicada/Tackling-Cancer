import numpy as np
import sys, re, os, cv2
import tempfile
import zipfile
import shutil
from flask import Flask
#import matplotlib.pyplot as plt

# this was generated by first drawing a perfect circle in a 20px square image (see circle.jpg)
# then the contours of the perfect circle were found, printed and pasted here
perfect_circle = np.array([[[ 1,  1]], [[ 1,  4]], [[ 2,  5]], [[ 2,  6]], [[ 1,  7]], [[ 1, 12]], [[ 2, 13]], [[ 2, 14]], [[ 1, 15]], [[ 1, 18]], [[ 4, 18]], [[ 5, 17]], [[ 6, 17]], [[ 7, 18]], [[12, 18]], [[13, 17]], [[14, 17]], [[15, 18]], [[18, 18]], [[18, 15]], [[17, 14]], [[17, 13]], [[18, 12]], [[18,  7]], [[17,  6]], [[17,  5]], [[18,  4]], [[18,  1]], [[15,  1]], [[14,  2]], [[13,  2]], [[12,  1]], [[ 7,  1]], [[ 6,  2]], [[ 5,  2]], [[ 4,  1]]])

# some constants
circle_similarity_threshold = 0.9
max_size_threshold = 30
min_size_threshold = 10

# connecting to the temp folder
TEMP_FOLDER = 'temp'
app = Flask(__name__)
app.config['TEMP_FOLDER'] = TEMP_FOLDER

def main(argv):
    
    # read the file
    filename = argv[0]
    src = cv2.imread(filename, cv2.IMREAD_COLOR)
    
    # make a temporary directory
    newpath = app.config['TEMP_FOLDER']
    #if not os.path.exists(newpath):
    #    os.makedirs(newpath, 777)

    # check it's an image file
    if src is None:
        sys.exit(filename + " could not be read as an image file")

    # convert to grey scale
    src_gray = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)
    
    # calculate the optimal threshold to apply
    optimal_threshold = getOptimalThreshold(src_gray)

    #print filename, optimal_threshold
    
    # Find contours
    ret, dst = cv2.threshold(src_gray, optimal_threshold, 255, 0)
    _, contours, hierarchy = cv2.findContours(dst, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    
    cells_found = 0;
    for i in range(0,len(contours)):
        
        if cv2.matchShapes(contours[i], perfect_circle, 1, 0) <= circle_similarity_threshold:
            
            # calculate the minimal bounding box to surround the countour
            x,y,w,h = cv2.boundingRect(contours[i])
            
            # filter out cells that are too elongated the wrong size
            if w <= max_size_threshold and h <= max_size_threshold and w >= min_size_threshold and h >= min_size_threshold:
    
                # Draw contours (to create a mask)
                drawing = np.zeros(src.shape, src.dtype)            
                cv2.drawContours(drawing, contours, i, (255,255,255), -1, 8, hierarchy, 0)
                
                # mask out the contoured cells
                cells = src & drawing
                
                # obtain a crop of this contour
                crop = cells[y: y + h, x: x + w]
                #crop = src[y: y + h, x: x + w]
                
                # write the image to a file
                cells_found += 1
                cell_filename = 'temp/' + re.sub('\.[^.]*$', "_cell_" + str(cells_found) + ".jpg", os.path.basename(filename))
                #cell_filename = re.sub('\.[^.]*$', "_cell_" + str(cells_found) + ".jpg", newpath)
                cv2.imwrite(cell_filename, crop, [cv2.IMWRITE_JPEG_QUALITY, 100])

    zipf = zipfile.ZipFile('uploads/temp.zip', 'w')
    zipdir(newpath, zipf)
    zipf.close()
    
    # Apply the mask to the source image to produce a new image
    #cells = src & drawing
    
    # Show the original image
    #cv2.namedWindow("Source", cv2.CV_WINDOW_AUTOSIZE)
    #cv2.imshow("Source", src)
    
    # Show original cells with a bitwise and application of the mask to the original image
    #cv2.namedWindow("Cells", cv2.CV_WINDOW_AUTOSIZE)
    #cv2.imshow("Cells", cells)

    #cv2.waitKey(0)

# provide a single access point to the methods of finding the optimal threshold
def getOptimalThreshold(src_gray):
    
    #optimal_threshold1 = getOptimalThreshold_maximiseCellCount(src_gray)
    #optimal_threshold2 = getOptimalThreshold_maximiseCellCountNoOutliers(src_gray)
    
    #print "Threshold 1", optimal_threshold1
    #print "Threshold 2", optimal_threshold2
    
    # prefer the higher of the thresholds
    #if optimal_threshold1 >= optimal_threshold2:
    #    return optimal_threshold1
    #else:
    #    return optimal_threshold2

    return getOptimalThreshold_maximiseCellCountNoOutliers(src_gray)
        
# returns a list of nonzero cells minus any outliers 
def reject_outliers(cells):

    # calculate the standard deviation of the list
    d = abs(cells - np.mean(cells))
    mdev = np.std(cells)
    s = d/mdev if mdev else 0.
    
    thresholds = range(0,255)
    nonoutlier_cells = []
    nonoutlier_thresholds = []
    
    # get rid of outliers
    for i in range(0,len(cells)):
    
        if s[i] < 2.0:
            nonoutlier_cells.append(cells[i])
            nonoutlier_thresholds.append(thresholds[i])
    
    # cut off the first and last 10% of values from the list
    chop_factor = abs(len(nonoutlier_cells)/10)
    nonoutlier_cells = nonoutlier_cells[chop_factor:len(nonoutlier_cells)-chop_factor]
    nonoutlier_thresholds = nonoutlier_thresholds[chop_factor:len(nonoutlier_thresholds)-chop_factor]
    
    return nonoutlier_thresholds, nonoutlier_cells

# finds the optimal threshold by searching for the maximum cells found minus any outliers
def getOptimalThreshold_maximiseCellCountNoOutliers(src_gray):
    
    optimal_threshold = 0
    max_cells_found = 0
    
    allcells_found = []
    
    for threshold in range(0,255):
        
        # find contours
        ret, dst = cv2.threshold(src_gray, threshold, 255, 0)
        _, contours, hierarchy = cv2.findContours(dst, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        
        # count contours
        cells_found = 0;
        for i in range(0,len(contours)):
                
            if cv2.matchShapes(contours[i], perfect_circle, 1, 0) <= circle_similarity_threshold:
                
                x,y,w,h = cv2.boundingRect(contours[i])
                    
                if w <= max_size_threshold and h <= max_size_threshold and w >= min_size_threshold and h >= min_size_threshold:
                    
                    cells_found += 1
                
        allcells_found.append(cells_found)
        
        #print "Number of cells found: ", threshold, cells_found

    thresholds, allcells_found = reject_outliers(allcells_found)
    
    max_cells_found = 0
    
    for i in range(len(allcells_found)):
        
        if allcells_found[i] >= max_cells_found:
            max_cells_found = allcells_found[i]
            optimal_threshold = thresholds[i]
    
    #plt.plot(allcells_found)
    #plt.ylabel('number of cells found')
    #plt.xlabel('threshold value')
    #plt.show()

    return optimal_threshold
    
# finds the optimal threshold by searching for the maximum cells found
def getOptimalThreshold_maximiseCellCount(src_gray):
    
    optimal_threshold = 0
    max_cells_found = 0
    
    for threshold in range(0,255):
    
        # find contours
        ret, dst = cv2.threshold(src_gray, threshold, 255, 0)
        contours, hierarchy = cv2.findContours(dst, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        
        # count contours
        cells_found = 0;
        for i in range(0,len(contours)):
                
            if cv2.matchShapes(contours[i], perfect_circle, 1, 0) <= circle_similarity_threshold:
                
                x,y,w,h = cv2.boundingRect(contours[i])
                    
                if w <= max_size_threshold and h <= max_size_threshold and w >= min_size_threshold and h >= min_size_threshold:
                    
                    cells_found += 1
                
        #print "Number of cells found: %6d" % cells_found
        
        if cells_found >= max_cells_found:
            max_cells_found = cells_found
            optimal_threshold = threshold

    return optimal_threshold

def zipdir(path, ziph):
    #ziph is zipfile handle 
    for root, dirs, files in os.walk(path):
        print root
        print dirs
        for f in files:
            print f
            ziph.write(os.path.join('temp/',f))

if __name__ == "__main__":
    main(sys.argv[1:])